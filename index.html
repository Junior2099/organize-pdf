<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="32x32" href="https://img.icons8.com/?size=100&id=47812&format=png&color=000000">
  <title>Visualizador de Arquivos</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 30px;
    }
    .upload-area {
      border: 2px dashed #aaa;
      padding: 40px 20px;
      text-align: center;
      margin-bottom: 30px;
      border-radius: 8px;
      background-color: #fafafa;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .upload-area:hover, .upload-area.dragover {
      border-color: #3498db;
      background-color: #eaf2f8;
    }
    .upload-area p {
      margin: 0 0 15px;
      font-size: 18px;
      color: #7f8c8d;
    }
    .upload-area button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .upload-area button:hover {
      background-color: #2980b9;
    }
    .preview {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 30px;
    }
    .pdf-container {
      border: 1px solid #eee;
      margin-bottom: 15px;
      border-radius: 5px;
      padding: 10px;
      background-color: #f9f9f9;
      width: 100%;
    }
    .pdf-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #eee;
    }
    .pdf-title {
      font-weight: bold;
      color: #2c3e50;
    }
    .pdf-pages {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .page-item {
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 3px;
      background-color: white;
      position: relative;
    }
    .page-item canvas {
      max-width: 150px;
      max-height: 200px;
      display: block;
    }
    .page-info {
      font-size: 12px;
      color: #7f8c8d;
      text-align: center;
      margin-top: 5px;
    }
    .remove-page-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .remove-pdf-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 3px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #95a5a6;
      font-size: 18px;
      width: 100%;
    }
    .actions {
      text-align: center;
      margin-top: 20px;
    }
    button#print-btn {
      background-color: #27ae60;
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 16px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button#print-btn:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    .progress-bar {
      width: 100%;
      height: 5px;
      background-color: #ecf0f1;
      border-radius: 5px;
      margin-top: 10px;
      overflow: hidden;
      display: none;
    }
    .progress {
      height: 100%;
      background-color: #3498db;
      width: 0%;
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Visualizador e Impressor de Arquivos</h1>
    
    <div class="upload-area" id="upload-area">
      <p>Arraste e solte arquivos PDF ou imagens aqui</p>
      <button id="select-files-btn">Selecionar Arquivos</button>
      <input type="file" id="file-input" multiple accept="application/pdf,image/jpeg,image/png" style="display:none;">
      <div class="progress-bar" id="progress-bar">
        <div class="progress" id="progress"></div>
      </div>
    </div>
    
    <div class="preview" id="preview">
      <div class="empty-state" id="empty-state">Nenhum arquivo carregado ainda</div>
    </div>
    
    <div class="actions">
      <button id="print-btn" disabled>Gerar PDF para Impressão</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>

    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    const { jsPDF } = window.jspdf;

    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const selectFilesBtn = document.getElementById('select-files-btn');
    const preview = document.getElementById('preview');
    const printBtn = document.getElementById('print-btn');
    const emptyState = document.getElementById('empty-state');
    const progressBar = document.getElementById('progress-bar');
    const progress = document.getElementById('progress');

    const files = {
      pdfs: [],
      images: []
    };

    uploadArea.addEventListener('click', () => fileInput.click());
    selectFilesBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      fileInput.click();
    });

    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        handleFiles(e.dataTransfer.files);
      }
    });

    fileInput.addEventListener('change', () => {
      if (fileInput.files.length > 0) {
        handleFiles(fileInput.files);
      }
    });

    printBtn.addEventListener('click', generatePDF);

    async function handleFiles(newFiles) {
      progressBar.style.display = 'block';
      progress.style.width = '0%';
      
      const validFiles = Array.from(newFiles).filter(file => 
        file.type === 'application/pdf' || file.type.startsWith('image/')
      );
      
      if (validFiles.length === 0) {
        alert('Por favor, selecione apenas arquivos PDF ou imagens (JPEG/PNG).');
        progressBar.style.display = 'none';
        return;
      }
      
      let processed = 0;
      const totalFiles = validFiles.length;
      
      for (const file of validFiles) {
        if (file.type === 'application/pdf') {
          await processPDFFile(file);
        } else if (file.type.startsWith('image/')) {
          await processImageFile(file);
        }
        
        processed++;
        progress.style.width = `${(processed / totalFiles) * 100}%`;
      }
      
      setTimeout(() => {
        progressBar.style.display = 'none';
      }, 500);
    }

    async function processPDFFile(file) {
      try {
        const pdfId = generateId();
        const pdfData = await readFileAsArrayBuffer(file);
        const pdfDoc = await pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise;
        
        const pdfObj = {
          id: pdfId,
          file: file,
          name: file.name,
          numPages: pdfDoc.numPages,
          pages: []
        };
        
        for (let i = 1; i <= pdfDoc.numPages; i++) {
          pdfObj.pages.push(i);
        }
        
        files.pdfs.push(pdfObj);
        renderPDFPreview(pdfObj);
        updateUI();
        
      } catch (error) {
        console.error('Error processing PDF:', error);
        alert(`Erro ao processar o PDF ${file.name}`);
      }
    }

    async function renderPDFPreview(pdfObj) {
      const container = document.createElement('div');
      container.className = 'pdf-container';
      container.id = `pdf-${pdfObj.id}`;
      
      const header = document.createElement('div');
      header.className = 'pdf-header';
      
      const title = document.createElement('div');
      title.className = 'pdf-title';
      title.textContent = pdfObj.name;
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-pdf-btn';
      removeBtn.textContent = 'Remover PDF';
      removeBtn.onclick = () => removePDF(pdfObj.id);
      
      header.appendChild(title);
      header.appendChild(removeBtn);
      
      const pagesContainer = document.createElement('div');
      pagesContainer.className = 'pdf-pages';
      
      container.appendChild(header);
      container.appendChild(pagesContainer);
      preview.insertBefore(container, emptyState);
      
      for (const pageNum of pdfObj.pages) {
        await renderPDFPage(pdfObj, pageNum);
      }
    }

    async function renderPDFPage(pdfObj, pageNum) {
      try {
        const pdfData = await readFileAsArrayBuffer(pdfObj.file);
        const pdfDoc = await pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise;
        const page = await pdfDoc.getPage(pageNum);
        
        const viewport = page.getViewport({ scale: 0.3 });
        const canvas = document.createElement('canvas');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        const context = canvas.getContext('2d');
        
        await page.render({ canvasContext: context, viewport }).promise;
        
        const pageItem = document.createElement('div');
        pageItem.className = 'page-item';
        pageItem.dataset.pdfId = pdfObj.id;
        pageItem.dataset.pageNum = pageNum;
        
        const pageNumber = document.createElement('div');
        pageNumber.className = 'page-info';
        pageNumber.textContent = `Página ${pageNum}`;
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-page-btn';
        removeBtn.innerHTML = '&times;';
        removeBtn.onclick = () => removePDFPage(pdfObj.id, pageNum);
        
        pageItem.appendChild(canvas);
        pageItem.appendChild(pageNumber);
        pageItem.appendChild(removeBtn);
        
        const container = document.getElementById(`pdf-${pdfObj.id}`);
        if (container) {
          const pagesContainer = container.querySelector('.pdf-pages');
          if (pagesContainer) {
            pagesContainer.appendChild(pageItem);
          }
        }
      } catch (error) {
        console.error('Error rendering PDF page:', error);
      }
    }

    function removePDF(pdfId) {
      files.pdfs = files.pdfs.filter(pdf => pdf.id !== pdfId);
      const container = document.getElementById(`pdf-${pdfId}`);
      if (container) {
        container.remove();
      }
      updateUI();
    }

    function removePDFPage(pdfId, pageNum) {
      const pdfObj = files.pdfs.find(pdf => pdf.id === pdfId);
      if (!pdfObj) return;
      
      pdfObj.pages = pdfObj.pages.filter(page => page !== pageNum);

      const pageElement = document.querySelector(`.page-item[data-pdf-id="${pdfId}"][data-page-num="${pageNum}"]`);
      if (pageElement) {
        pageElement.remove();
      }
      
      if (pdfObj.pages.length === 0) {
        removePDF(pdfId);
      }
      
      updateUI();
    }

    async function processImageFile(file) {
      try {
        const imgId = generateId();
        const imgData = await readFileAsDataURL(file);
        
        files.images.push({
          id: imgId,
          file: file,
          data: imgData
        });
        
        renderImagePreview(imgId, file.name, imgData);
        updateUI();
        
      } catch (error) {
        console.error('Error processing image:', error);
        alert(`Erro ao processar a imagem ${file.name}`);
      }
    }

    function renderImagePreview(imgId, fileName, imgData) {
      const container = document.createElement('div');
      container.className = 'pdf-container';
      container.id = `img-${imgId}`;
      
      const header = document.createElement('div');
      header.className = 'pdf-header';
      
      const title = document.createElement('div');
      title.className = 'pdf-title';
      title.textContent = fileName;
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-pdf-btn';
      removeBtn.textContent = 'Remover Imagem';
      removeBtn.onclick = () => removeImage(imgId);
      
      header.appendChild(title);
      header.appendChild(removeBtn);
      
      const imgContainer = document.createElement('div');
      imgContainer.className = 'pdf-pages';
      imgContainer.style.padding = '10px';
      
      const imgElement = document.createElement('img');
      imgElement.src = imgData;
      imgElement.style.maxWidth = '200px';
      imgElement.style.maxHeight = '200px';
      
      imgContainer.appendChild(imgElement);
      container.appendChild(header);
      container.appendChild(imgContainer);
      preview.insertBefore(container, emptyState);
    }

    function removeImage(imgId) {
      files.images = files.images.filter(img => img.id !== imgId);
      const container = document.getElementById(`img-${imgId}`);
      if (container) {
        container.remove();
      }
      updateUI();
    }

    function updateUI() {
      emptyState.style.display = (files.pdfs.length === 0 && files.images.length === 0) ? 'block' : 'none';
      printBtn.disabled = (files.pdfs.length === 0 && files.images.length === 0);
    }

    async function generatePDF() {
      if (files.pdfs.length === 0 && files.images.length === 0) return;
      
      printBtn.disabled = true;
      printBtn.textContent = 'Gerando PDF...';
      progressBar.style.display = 'block';
      progress.style.width = '0%';
      
      try {
        const pdf = new jsPDF();
        let positionY = 20;
        let processed = 0;
        const totalPages = countSelectedPages();
        
        for (const pdfObj of files.pdfs) {
          const pdfData = await readFileAsArrayBuffer(pdfObj.file);
          const pdfDoc = await pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise;
          
          for (const pageNum of pdfObj.pages) {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.0 });
            
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const context = canvas.getContext('2d');
            
            await page.render({ canvasContext: context, viewport }).promise;
            
            const imgData = canvas.toDataURL('image/jpeg', 0.8);
            
            if (processed > 0 || positionY > 20) {
              pdf.addPage();
              positionY = 20;
            }
            
            const imgWidth = pdf.internal.pageSize.getWidth() - 20;
            const imgHeight = (canvas.height * imgWidth) / canvas.width;
            
            pdf.addImage(imgData, 'JPEG', 10, positionY, imgWidth, imgHeight);
            
            processed++;
            progress.style.width = `${(processed / totalPages) * 100}%`;
          }
        }
        
        for (const imgObj of files.images) {
          const img = new Image();
          
          await new Promise((resolve) => {
            img.onload = resolve;
            img.src = imgObj.data;
          });
          
          if (processed > 0 || positionY > 20) {
            pdf.addPage();
            positionY = 20;
          }
          
          const imgWidth = pdf.internal.pageSize.getWidth() - 20;
          const imgHeight = (img.height * imgWidth) / img.width;
          
          if (imgHeight > pdf.internal.pageSize.getHeight() - positionY - 20) {
            pdf.addPage();
            positionY = 20;
          }
          
          pdf.addImage(imgObj.data, 'JPEG', 10, positionY, imgWidth, imgHeight);
          positionY += imgHeight + 10;
          
          processed++;
          progress.style.width = `${(processed / totalPages) * 100}%`;
        }
        
        const pdfBlob = pdf.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);
        window.open(pdfUrl, '_blank');
        
      } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Ocorreu um erro ao gerar o PDF. Por favor, tente novamente.');
      } finally {
        printBtn.disabled = false;
        printBtn.textContent = 'Gerar PDF para Impressão';
        progressBar.style.display = 'none';
      }
    }

    function countSelectedPages() {
      let count = 0;
      
      for (const pdfObj of files.pdfs) {
        count += pdfObj.pages.length;
      }
      
      count += files.images.length;
      
      return count;
    }

    function generateId() {
      return Math.random().toString(36).substr(2, 9);
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsArrayBuffer(file);
      });
    }

    function readFileAsDataURL(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(file);
      });
    }
  </script>
</body>
</html>
